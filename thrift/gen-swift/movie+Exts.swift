/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: TMDBMovie, rhs: TMDBMovie) -> Bool {
  return
    (lhs.adult == rhs.adult) &&
    (lhs.backdropPath == rhs.backdropPath) &&
    (lhs.budget == rhs.budget) &&
    (lhs.genres == rhs.genres) &&
    (lhs.homepage == rhs.homepage) &&
    (lhs.id == rhs.id) &&
    (lhs.imdbID == rhs.imdbID) &&
    (lhs.originalLanguage == rhs.originalLanguage) &&
    (lhs.originalTitle == rhs.originalTitle) &&
    (lhs.overview == rhs.overview) &&
    (lhs.popularity == rhs.popularity) &&
    (lhs.posterPath == rhs.posterPath) &&
    (lhs.productionCompanies == rhs.productionCompanies) &&
    (lhs.productionCountries == rhs.productionCountries) &&
    (lhs.releaseDate == rhs.releaseDate) &&
    (lhs.revenue == rhs.revenue) &&
    (lhs.runtime == rhs.runtime) &&
    (lhs.spokenLanguages == rhs.spokenLanguages) &&
    (lhs.status == rhs.status) &&
    (lhs.tagline == rhs.tagline) &&
    (lhs.title == rhs.title) &&
    (lhs.video == rhs.video) &&
    (lhs.voteAverage == rhs.voteAverage) &&
    (lhs.voteCount == rhs.voteCount)
}

extension TMDBMovie : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovie("
    desc += "adult=\(String(describing: self.adult)), "
    desc += "backdropPath=\(String(describing: self.backdropPath)), "
    desc += "budget=\(String(describing: self.budget)), "
    desc += "genres=\(String(describing: self.genres)), "
    desc += "homepage=\(String(describing: self.homepage)), "
    desc += "id=\(String(describing: self.id)), "
    desc += "imdbID=\(String(describing: self.imdbID)), "
    desc += "originalLanguage=\(String(describing: self.originalLanguage)), "
    desc += "originalTitle=\(String(describing: self.originalTitle)), "
    desc += "overview=\(String(describing: self.overview)), "
    desc += "popularity=\(String(describing: self.popularity)), "
    desc += "posterPath=\(String(describing: self.posterPath)), "
    desc += "productionCompanies=\(String(describing: self.productionCompanies)), "
    desc += "productionCountries=\(String(describing: self.productionCountries)), "
    desc += "releaseDate=\(String(describing: self.releaseDate)), "
    desc += "revenue=\(String(describing: self.revenue)), "
    desc += "runtime=\(String(describing: self.runtime)), "
    desc += "spokenLanguages=\(String(describing: self.spokenLanguages)), "
    desc += "status=\(String(describing: self.status)), "
    desc += "tagline=\(String(describing: self.tagline)), "
    desc += "title=\(String(describing: self.title)), "
    desc += "video=\(String(describing: self.video)), "
    desc += "voteAverage=\(String(describing: self.voteAverage)), "
    desc += "voteCount=\(String(describing: self.voteCount))"
    return desc
  }

}

extension TMDBMovie : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (adult.hashValue)
    result = prime &* result &+ (backdropPath.hashValue)
    result = prime &* result &+ (budget.hashValue)
    result = prime &* result &+ (genres.hashValue)
    result = prime &* result &+ (homepage.hashValue)
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (imdbID.hashValue)
    result = prime &* result &+ (originalLanguage.hashValue)
    result = prime &* result &+ (originalTitle.hashValue)
    result = prime &* result &+ (overview.hashValue)
    result = prime &* result &+ (popularity.hashValue)
    result = prime &* result &+ (posterPath?.hashValue ?? 0)
    result = prime &* result &+ (productionCompanies.hashValue)
    result = prime &* result &+ (productionCountries.hashValue)
    result = prime &* result &+ (releaseDate.hashValue)
    result = prime &* result &+ (revenue.hashValue)
    result = prime &* result &+ (runtime.hashValue)
    result = prime &* result &+ (spokenLanguages.hashValue)
    result = prime &* result &+ (status.hashValue)
    result = prime &* result &+ (tagline.hashValue)
    result = prime &* result &+ (title.hashValue)
    result = prime &* result &+ (video.hashValue)
    result = prime &* result &+ (voteAverage.hashValue)
    result = prime &* result &+ (voteCount.hashValue)
    return result
  }

}

extension TMDBMovie : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["adult": 1, "backdropPath": 2, "budget": 3, "genres": 4, "homepage": 5, "id": 6, "imdbID": 7, "originalLanguage": 8, "originalTitle": 9, "overview": 10, "popularity": 11, "posterPath": 12, "productionCompanies": 13, "productionCountries": 14, "releaseDate": 15, "revenue": 16, "runtime": 17, "spokenLanguages": 18, "status": 19, "tagline": 20, "title": 21, "video": 22, "voteAverage": 23, "voteCount": 24, ]
  }

  public static var structName: String { return "TMDBMovie" }

  public static func read(from proto: TProtocol) throws -> TMDBMovie {
    _ = try proto.readStructBegin()
    var adult: Bool!
    var backdropPath: String!
    var budget: Int32!
    var genres: TList<TMDBMovieGenre>!
    var homepage: String!
    var id: Int32!
    var imdbID: String!
    var originalLanguage: String!
    var originalTitle: String!
    var overview: String!
    var popularity: Double!
    var posterPath: String?
    var productionCompanies: TList<TMDBMovieProductionCompany>!
    var productionCountries: TList<TMDBMovieProductionCountry>!
    var releaseDate: String!
    var revenue: Int32!
    var runtime: Int32!
    var spokenLanguages: TList<TMDBMovieSpokenLanguage>!
    var status: String!
    var tagline: String!
    var title: String!
    var video: Bool!
    var voteAverage: Double!
    var voteCount: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            adult = try Bool.read(from: proto)
        case (2, .string):           backdropPath = try String.read(from: proto)
        case (3, .i32):             budget = try Int32.read(from: proto)
        case (4, .list):            genres = try TList<TMDBMovieGenre>.read(from: proto)
        case (5, .string):           homepage = try String.read(from: proto)
        case (6, .i32):             id = try Int32.read(from: proto)
        case (7, .string):           imdbID = try String.read(from: proto)
        case (8, .string):           originalLanguage = try String.read(from: proto)
        case (9, .string):           originalTitle = try String.read(from: proto)
        case (10, .string):           overview = try String.read(from: proto)
        case (11, .double):           popularity = try Double.read(from: proto)
        case (12, .string):           posterPath = try String.read(from: proto)
        case (13, .list):            productionCompanies = try TList<TMDBMovieProductionCompany>.read(from: proto)
        case (14, .list):            productionCountries = try TList<TMDBMovieProductionCountry>.read(from: proto)
        case (15, .string):           releaseDate = try String.read(from: proto)
        case (16, .i32):             revenue = try Int32.read(from: proto)
        case (17, .i32):             runtime = try Int32.read(from: proto)
        case (18, .list):            spokenLanguages = try TList<TMDBMovieSpokenLanguage>.read(from: proto)
        case (19, .string):           status = try String.read(from: proto)
        case (20, .string):           tagline = try String.read(from: proto)
        case (21, .string):           title = try String.read(from: proto)
        case (22, .bool):            video = try Bool.read(from: proto)
        case (23, .double):           voteAverage = try Double.read(from: proto)
        case (24, .i32):             voteCount = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adult, named: "adult")
    try proto.validateValue(backdropPath, named: "backdropPath")
    try proto.validateValue(budget, named: "budget")
    try proto.validateValue(genres, named: "genres")
    try proto.validateValue(homepage, named: "homepage")
    try proto.validateValue(id, named: "id")
    try proto.validateValue(imdbID, named: "imdbID")
    try proto.validateValue(originalLanguage, named: "originalLanguage")
    try proto.validateValue(originalTitle, named: "originalTitle")
    try proto.validateValue(overview, named: "overview")
    try proto.validateValue(popularity, named: "popularity")
    try proto.validateValue(productionCompanies, named: "productionCompanies")
    try proto.validateValue(productionCountries, named: "productionCountries")
    try proto.validateValue(releaseDate, named: "releaseDate")
    try proto.validateValue(revenue, named: "revenue")
    try proto.validateValue(runtime, named: "runtime")
    try proto.validateValue(spokenLanguages, named: "spokenLanguages")
    try proto.validateValue(status, named: "status")
    try proto.validateValue(tagline, named: "tagline")
    try proto.validateValue(title, named: "title")
    try proto.validateValue(video, named: "video")
    try proto.validateValue(voteAverage, named: "voteAverage")
    try proto.validateValue(voteCount, named: "voteCount")

    return TMDBMovie(adult: adult, backdropPath: backdropPath, budget: budget, genres: genres, homepage: homepage, id: id, imdbID: imdbID, originalLanguage: originalLanguage, originalTitle: originalTitle, overview: overview, popularity: popularity, posterPath: posterPath, productionCompanies: productionCompanies, productionCountries: productionCountries, releaseDate: releaseDate, revenue: revenue, runtime: runtime, spokenLanguages: spokenLanguages, status: status, tagline: tagline, title: title, video: video, voteAverage: voteAverage, voteCount: voteCount)
  }

}



public func ==(lhs: TMDBMovieGenre, rhs: TMDBMovieGenre) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name)
}

extension TMDBMovieGenre : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovieGenre("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension TMDBMovieGenre : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension TMDBMovieGenre : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, ]
  }

  public static var structName: String { return "TMDBMovieGenre" }

  public static func read(from proto: TProtocol) throws -> TMDBMovieGenre {
    _ = try proto.readStructBegin()
    var id: Int32!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")

    return TMDBMovieGenre(id: id, name: name)
  }

}



public func ==(lhs: TMDBMovieProductionCompany, rhs: TMDBMovieProductionCompany) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.logoPath == rhs.logoPath) &&
    (lhs.name == rhs.name) &&
    (lhs.originCountry == rhs.originCountry)
}

extension TMDBMovieProductionCompany : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovieProductionCompany("
    desc += "id=\(String(describing: self.id)), "
    desc += "logoPath=\(String(describing: self.logoPath)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "originCountry=\(String(describing: self.originCountry))"
    return desc
  }

}

extension TMDBMovieProductionCompany : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (logoPath?.hashValue ?? 0)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (originCountry.hashValue)
    return result
  }

}

extension TMDBMovieProductionCompany : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "logoPath": 2, "name": 3, "originCountry": 4, ]
  }

  public static var structName: String { return "TMDBMovieProductionCompany" }

  public static func read(from proto: TProtocol) throws -> TMDBMovieProductionCompany {
    _ = try proto.readStructBegin()
    var id: Int32!
    var logoPath: String?
    var name: String!
    var originCountry: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           logoPath = try String.read(from: proto)
        case (3, .string):           name = try String.read(from: proto)
        case (4, .string):           originCountry = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(originCountry, named: "originCountry")

    return TMDBMovieProductionCompany(id: id, logoPath: logoPath, name: name, originCountry: originCountry)
  }

}



public func ==(lhs: TMDBMovieProductionCountry, rhs: TMDBMovieProductionCountry) -> Bool {
  return
    (lhs.iso3166_1 == rhs.iso3166_1) &&
    (lhs.name == rhs.name)
}

extension TMDBMovieProductionCountry : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovieProductionCountry("
    desc += "iso3166_1=\(String(describing: self.iso3166_1)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension TMDBMovieProductionCountry : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (iso3166_1.hashValue)
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension TMDBMovieProductionCountry : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iso3166_1": 1, "name": 2, ]
  }

  public static var structName: String { return "TMDBMovieProductionCountry" }

  public static func read(from proto: TProtocol) throws -> TMDBMovieProductionCountry {
    _ = try proto.readStructBegin()
    var iso3166_1: String!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           iso3166_1 = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iso3166_1, named: "iso3166_1")
    try proto.validateValue(name, named: "name")

    return TMDBMovieProductionCountry(iso3166_1: iso3166_1, name: name)
  }

}



public func ==(lhs: TMDBMovieSpokenLanguage, rhs: TMDBMovieSpokenLanguage) -> Bool {
  return
    (lhs.iso639_1 == rhs.iso639_1) &&
    (lhs.name == rhs.name)
}

extension TMDBMovieSpokenLanguage : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovieSpokenLanguage("
    desc += "iso639_1=\(String(describing: self.iso639_1)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension TMDBMovieSpokenLanguage : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (iso639_1.hashValue)
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension TMDBMovieSpokenLanguage : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["iso639_1": 1, "name": 2, ]
  }

  public static var structName: String { return "TMDBMovieSpokenLanguage" }

  public static func read(from proto: TProtocol) throws -> TMDBMovieSpokenLanguage {
    _ = try proto.readStructBegin()
    var iso639_1: String!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           iso639_1 = try String.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(iso639_1, named: "iso639_1")
    try proto.validateValue(name, named: "name")

    return TMDBMovieSpokenLanguage(iso639_1: iso639_1, name: name)
  }

}



public func ==(lhs: TMDBMovieError, rhs: TMDBMovieError) -> Bool {
  return
    (lhs.code == rhs.code) &&
    (lhs.message == rhs.message)
}

extension TMDBMovieError : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBMovieError("
    desc += "code=\(String(describing: self.code)), "
    desc += "message=\(String(describing: self.message))"
    return desc
  }

}

extension TMDBMovieError : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (code.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension TMDBMovieError : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["code": 1, "message": 2, ]
  }

  public static var structName: String { return "TMDBMovieError" }

  public static func read(from proto: TProtocol) throws -> TMDBMovieError {
    _ = try proto.readStructBegin()
    var code: Int32!
    var message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             code = try Int32.read(from: proto)
        case (2, .string):           message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(code, named: "code")
    try proto.validateValue(message, named: "message")

    return TMDBMovieError(code: code, message: message)
  }

}



public func ==(lhs: TMDBGetDetailsRequest, rhs: TMDBGetDetailsRequest) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.apiKey == rhs.apiKey) &&
    (lhs.language == rhs.language)
}

extension TMDBGetDetailsRequest : CustomStringConvertible {

  public var description : String {
    var desc = "TMDBGetDetailsRequest("
    desc += "id=\(String(describing: self.id)), "
    desc += "apiKey=\(String(describing: self.apiKey)), "
    desc += "language=\(String(describing: self.language))"
    return desc
  }

}

extension TMDBGetDetailsRequest : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (apiKey.hashValue)
    result = prime &* result &+ (language?.hashValue ?? 0)
    return result
  }

}

extension TMDBGetDetailsRequest : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "apiKey": 2, "language": 3, ]
  }

  public static var structName: String { return "TMDBGetDetailsRequest" }

  public static func read(from proto: TProtocol) throws -> TMDBGetDetailsRequest {
    _ = try proto.readStructBegin()
    var id: Int32!
    var apiKey: String!
    var language: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           apiKey = try String.read(from: proto)
        case (3, .string):           language = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(apiKey, named: "apiKey")

    return TMDBGetDetailsRequest(id: id, apiKey: apiKey, language: language)
  }

}



fileprivate final class MovieService_getDetails_args {

  fileprivate var req: TMDBGetDetailsRequest


  fileprivate init(req: TMDBGetDetailsRequest) {
    self.req = req
  }

}

fileprivate func ==(lhs: MovieService_getDetails_args, rhs: MovieService_getDetails_args) -> Bool {
  return
    (lhs.req == rhs.req)
}

extension MovieService_getDetails_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (req.hashValue)
    return result
  }

}

extension MovieService_getDetails_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["req": 1, ]
  }

  fileprivate static var structName: String { return "MovieService_getDetails_args" }

  fileprivate static func read(from proto: TProtocol) throws -> MovieService_getDetails_args {
    _ = try proto.readStructBegin()
    var req: TMDBGetDetailsRequest!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           req = try TMDBGetDetailsRequest.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(req, named: "req")

    return MovieService_getDetails_args(req: req)
  }

}



fileprivate final class MovieService_getDetails_result {

  fileprivate var success: TMDBMovie?

  fileprivate var error: TMDBMovieError?


  fileprivate init() { }
  fileprivate init(success: TMDBMovie?, error: TMDBMovieError?) {
    self.success = success
    self.error = error
  }

}

fileprivate func ==(lhs: MovieService_getDetails_result, rhs: MovieService_getDetails_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.error == rhs.error)
}

extension MovieService_getDetails_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension MovieService_getDetails_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "error": 1, ]
  }

  fileprivate static var structName: String { return "MovieService_getDetails_result" }

  fileprivate static func read(from proto: TProtocol) throws -> MovieService_getDetails_result {
    _ = try proto.readStructBegin()
    var success: TMDBMovie?
    var error: TMDBMovieError?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try TMDBMovie.read(from: proto)
        case (1, .struct):           error = try TMDBMovieError.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MovieService_getDetails_result(success: success, error: error)
  }

}



extension MovieServiceClient : MovieService {

  private func send_getDetails(req: TMDBGetDetailsRequest) throws {
    try outProtocol.writeMessageBegin(name: "getDetails", type: .call, sequenceID: 0)
    let args = MovieService_getDetails_args(req: req)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDetails() throws -> TMDBMovie {
    try inProtocol.readResultMessageBegin() 
    let result = try MovieService_getDetails_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let error = result.error {
      throw error
    }
    throw TApplicationError(error: .missingResult(methodName: "getDetails"))
  }

  public func getDetails(req: TMDBGetDetailsRequest) throws -> TMDBMovie {
    try send_getDetails(req: req)
    try outProtocol.transport.flush()
    return try recv_getDetails()
  }

}

extension MovieServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["getDetails"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try MovieService_getDetails_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = MovieService_getDetails_result()
      do {
        result.success = try handler.getDetails(req: args.req)
      }
      catch let error as TMDBMovieError { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDetails", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = MovieServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

